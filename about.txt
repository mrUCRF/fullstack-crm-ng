генерируем файл package.json для записи все зависимостей для нашего проекта - npm init

создаем index.json
начинаем с бэкенда:
устанавливаем express - npm install express
подкл express в index.js файл
создаем экземпляр express в файле js
запускаем сервер - $ node index.js

созд ф app.js / module.exports = app  - экспортируем наружу апп

const port = process.env.PORT || 5000 --- возможность в консоли указывать порт, или 5000
kill $(lsof -ti:5000)  -- убить порт
в файле package.json пишем команду скрипта вместо 'test' -  "start": "node index"

чтобы каждый раз вручную не перезапускать сервер при изменениях, ставим пакет npm i nodemon --save-dev
и добавляем в скрипты package.json - "server": "nodemon index"
!!!npm run server!!! запускаем сервак  (npm run start запускает только разово сервер)
control+C    ----  остановка сервера

создаем файл для auth роутинга, в нем создаем локальный router, делаем экспорт, создали тестовый гет запрос, подключаем и регистрируем(app.use()) auth роутер в файле app.js

создаем контроллеры

ур.13 - создание всех роутов
создаем роуты и контроллеры для них
подключаем все роуты в файле app.js и активируем методом app.use все роуты и прописываем пути 
потом в самих роутах прописываем пути и метод api запроса
ур14
тестить запросы можно с помощ иснтрумента postman (т.к в браузере можно просматривать только get запросы) (есть еще Swager)
чтобы express понимал поля как обьекты js нужно установить пакет который будет за нас парсить все данные которые будут приходить от пользователя
npm install body-parser
в файле app.js подключаем разные плагины ( в т.ч body parser) с помощ required и добавлям app.use(bodyParser.urlencoded({extended: true}))
app.use(bodyParser.json())

в auth котроллере прописываем ключи почты и пароля, и значения получаем с req.body.email, в postman можно в разделе body->raw->JSON создать данные запроса с такими же ключами которые прописаны в контроллере, и запрос будет принимать эти ключи
ур.15
npm i cors morgan  ---- устанавливаем два пакета cors и morgan
и подключаем их в app.js
cors - если клиент будет находится на другом домене то мы всеравно сможем отвечать нашим серверам
morgan - что бы могли логировать запросы (смотреть что просиходит с сервером в данный момент)

ур16 подкл mongoDB
монго не будем устанавливать локально на комп, воспользуемся сервисом mLab(удаленный сервер)
с помощью инструмента mongoose подключаем серверную базу данных:
npm i mongoose
и подключаем в app.js
связываем mongoDB с mongoose - mongoose.connect('').then.catch
создаем папку config  c keys, ложим туда ключ-путь к серверной базе mongoDB(которую создали) и вписываем ее в '' коннект в файле app.js

ур17
создаем пользователя на стороне бекенд
!!!упущено создание моделей для работы с базой данных
создали исходя из модели модуль с регистрацией в контроллере auth.js и сохранили его, потом .then и вывели в консоль уведомление
отправляем проверочный запрос в postman и в консоли vscode пришло уведомление о добавлении пользователя
на сервер БД в разделе collections появилась сущность users 
удаляем на сайте сервера тестовый запрос
ур18 авторизация и регистрация
findOne() - метод поиска любого элемента в mongoose (применяем в асинхронной функции) в мангусе любые методы асинхронные
http status codes - ищем список всех статусов в данном протоколе (client error и тд.)
ур 19
пользуемся асинхронщиной + try/catch
шифруем пароль с помощ. пакета bcryptjs
подключаем его к контроллеру auth с помощ require
const salt = bcriptjs.genSaltSync(10) - создаем соль для генерации хеша для защиты пароля
password: bcriptjs.hashSync(password, salt)
ур.20
функцию логинизации делаем
bcriptjs.compareSync() - сравнение паролей в синхронном режиме
JWT - json web token - пакет для генерации токенов доступа
npm install jsonwebtoken
подключаем в контроллер auth.js
const token = jwt.sign({1й параметр данные которые хотим зашифровать}, 2й - ключ который позволит генерировать данные(создаем ключ в файле keys), {3й - время жизни токена expiresIn: 60 * 60 (получаем час)
jwt.io  - расшифровка токенов
token: `Bearer ${token}` - отправка на клиента с префиксом Bearer

ур21 защита роутов passportJS
устанавливаем passportjs и необходимую нам стратегию passport-jwt - авторизация через jwt токена
npm install passport passport-jwt
и подкл в app.js
создаем папку middleware -> passport.js
в passport.js подключаем const JwtStrategy = require('passport-jwt').Strategy
const ExtractJwt = require('passport-jwt').ExtractJwt
потом генерируем обьект опций для работі со статегией
что бы применить защиту, в роуте вторым параметром прописываем passport.authenticate('jwt', {session:false})